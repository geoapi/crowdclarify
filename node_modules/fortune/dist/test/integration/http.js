'use strict';

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _interopRequireWildcard = require('babel-runtime/helpers/interop-require-wildcard')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = httpTest;

var _tapdance = require('tapdance');

var _test_instance = require('./test_instance');

var _test_instance2 = _interopRequireDefault(_test_instance);

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _lib = require('../../lib');

var _lib2 = _interopRequireDefault(_lib);

var _stderr = require('../stderr');

var stderr = _interopRequireWildcard(_stderr);

var port = 1337;

function httpTest(options, path, request, fn, change) {
  var store = undefined;
  var server = undefined;

  return (0, _test_instance2['default'])(options).then(function (instance) {
    store = instance;

    if (typeof change === 'function') store.on(_lib2['default'].change, function (data) {
      return change(data, _lib2['default'].methods);
    });

    var listener = _lib2['default'].net.http(store);

    server = _http2['default'].createServer(function (request, response) {
      listener(request, response)['catch'](function (error) {
        return stderr.error(error);
      });
    }).listen(port);

    var headers = undefined;
    var status = undefined;

    if (request && typeof request.body === 'object') {
      request.body = JSON.stringify(request.body);
      if (!request.headers) request.headers = {};
      request.headers['Content-Length'] = Buffer.byteLength(request.body);
    }

    return new _Promise(function (resolve, reject) {
      return _http2['default'].request(_Object$assign({ port: port, path: path }, request), function (response) {
        headers = response.headers;
        status = response.statusCode;

        var chunks = [];

        response.on('error', reject);
        response.on('data', function (chunk) {
          return chunks.push(chunk);
        });
        response.on('end', function () {
          return resolve(Buffer.concat(chunks));
        });
      }).end(request ? request.body : null);
    }).then(function (response) {
      server.close();
      stderr.debug(_chalk2['default'].bold('Response status: ' + status));
      stderr.debug(headers);
      return store.disconnect().then(function () {
        return response.toString();
      });
    }).then(function (text) {
      try {
        if (text.length) {
          text = JSON.parse(text);
          stderr.log(text);
        }
      } catch (error) {
        stderr.warn('Failed to parse JSON.');
        stderr.log(text);
      }

      return fn({
        status: status,
        headers: headers,
        body: text
      });
    });
  })['catch'](function (error) {
    stderr.error(error);
    if (server) server.close();
    (0, _tapdance.fail)(error);
  });
}

module.exports = exports['default'];