'use strict';

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Object$getOwnPropertySymbols = require('babel-runtime/core-js/object/get-own-property-symbols')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _interopRequireWildcard = require('babel-runtime/helpers/interop-require-wildcard')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _lib = require('../../lib');

var _lib2 = _interopRequireDefault(_lib);

var _stderr = require('../stderr');

var stderr = _interopRequireWildcard(_stderr);

var _fixtures = require('../fixtures');

var fixtures = _interopRequireWildcard(_fixtures);

var inParens = /\(([^\)]+)\)/;
var change = _lib2['default'].change;
var methods = _lib2['default'].methods;

exports['default'] = function (options) {
  var store = _lib2['default'].create(options).defineType('user', {
    name: { type: String },
    camelCaseField: { type: String },
    birthday: { type: Date },
    picture: { type: Buffer },
    createdAt: { type: Date },
    lastModified: { type: Date },
    nicknames: { type: String, isArray: true },

    // Many to many
    friends: { link: 'user', inverse: 'friends', isArray: true },

    // Many to many, denormalized inverse
    enemies: { link: 'user', isArray: true },

    // One to one
    spouse: { link: 'user', inverse: 'spouse' },

    // Many to one
    ownedPets: { link: 'animal', inverse: 'owner', isArray: true }
  }).transformInput(function (context, record, update) {
    var method = context.request.method;

    if (method === methods.create) {
      record.createdAt = new Date();
      return record;
    }

    if (method === methods.update) {
      if (!('replace' in update)) update.replace = {};
      update.replace.lastModified = new Date();
      return update;
    }

    // For the `delete` method, return value doesn't matter.
    return null;
  }).transformOutput(function (context, record) {
    record.timestamp = Date.now();
    return _Promise.resolve(record);
  }).defineType('animal', {
    name: { type: String },

    // Implementations may have problems with this reserved word.
    type: { type: String },

    favoriteFood: { type: String },

    birthday: { type: Date },
    createdAt: { type: Date },
    lastModified: { type: Date },
    picture: { type: Buffer },
    nicknames: { type: String, isArray: true },

    // One to many
    owner: { link: 'user', inverse: 'ownedPets' }
  }).transformInput(function (context, record, update) {
    var method = context.request.method;

    if (method === methods.create) {
      record.createdAt = new Date();
      return record;
    }

    if (method === methods.update) {
      if (!('replace' in update)) update.replace = {};
      update.replace.lastModified = new Date();
      return update;
    }

    // For the `delete` method, return value doesn't matter.
    return null;
  }).transformOutput(function (context, record) {
    record.virtualProperty = 123;
    return record;
  }).defineType('â˜¯', {});

  store.on(change, function (data) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _getIterator(_Object$getOwnPropertySymbols(data)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var symbol = _step.value;

        assignDescription(data, symbol);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    stderr.info(_chalk2['default'].bold('Change event:'), data);
  });

  return store.connect()

  // Delete all previous records.
  .then(function () {
    return _Promise.all(_Object$keys(fixtures).map(function (type) {
      return store.adapter['delete'](type);
    }));
  })

  // Create fixtures.
  .then(function () {
    return _Promise.all(_Object$keys(fixtures).map(function (type) {
      return store.adapter.create(type, fixtures[type]);
    }));
  }).then(function () {
    return store;
  })['catch'](function (error) {
    store.disconnect();
    throw error;
  });
};

function assignDescription(object, symbol) {
  var description = (symbol.toString().match(inParens) || [])[1];
  if (description) object[description] = object[symbol];
}
module.exports = exports['default'];