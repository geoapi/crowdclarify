'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _common = require('../common');

var _commonApply_update = require('../../../common/apply_update');

var _commonApply_update2 = _interopRequireDefault(_commonApply_update);

var _commonGlobal_object = require('../../../common/global_object');

var _commonGlobal_object2 = _interopRequireDefault(_commonGlobal_object);

var _helpers = require('./helpers');

var _getGlobalObject = (0, _commonGlobal_object2['default'])();

var indexedDB = _getGlobalObject.indexedDB;

/**
 * IndexedDB adapter. Available options:
 *
 * - `name`: Name of the database to connect to. Default: `fortune`.
 */

exports['default'] = function (Adapter) {
  return (function (_Adapter) {
    _inherits(IndexedDBAdapter, _Adapter);

    function IndexedDBAdapter() {
      _classCallCheck(this, IndexedDBAdapter);

      _get(Object.getPrototypeOf(IndexedDBAdapter.prototype), 'constructor', this).apply(this, arguments);
    }

    _createClass(IndexedDBAdapter, [{
      key: 'connect',
      value: function connect() {
        var _this = this;

        var recordTypes = this.recordTypes;
        var options = this.options;
        var primaryKey = this.keys.primary;

        var name = options.name || 'fortune';
        var request = indexedDB.open(name);

        var handleUpgrade = function handleUpgrade(event) {
          var db = event.target.result;

          for (var type in recordTypes) {
            if (! ~Array.prototype.indexOf.call(db.objectStoreNames, type)) db.createObjectStore(type, { keyPath: primaryKey });
          }Array.prototype.forEach.call(db.objectStoreNames, function (type) {
            return !(type in recordTypes) ? db.deleteObjectStore(type) : null;
          });
        };

        var reconnect = function reconnect(db, resolve, reject) {
          var version = (db.version || 1) + 1;
          db.close();

          var request = indexedDB.open(name, version);
          request.onerror = reject;
          request.onupgradeneeded = handleUpgrade;
          request.onsuccess = function (event) {
            _this.db = event.target.result;
            return resolve();
          };
        };

        return new _Promise(function (resolve, reject) {
          request.onerror = reject;
          request.onupgradeneeded = handleUpgrade;
          request.onsuccess = function (event) {
            var db = _this.db = event.target.result;
            var needUpgrade = false;

            for (var type in recordTypes) {
              if (! ~Array.prototype.indexOf.call(db.objectStoreNames, type)) needUpgrade = true;
            }return needUpgrade ? reconnect(db, resolve, reject) : resolve();
          };
        });
      }
    }, {
      key: 'disconnect',
      value: function disconnect() {
        this.db.close();
        return _Promise.resolve();
      }
    }, {
      key: 'create',
      value: function create(type, records) {
        var _this2 = this;

        records = records.map(_helpers.inputRecord.bind(this, type));

        var db = this.db;
        var ConflictError = this.errors.ConflictError;

        var transaction = db.transaction(type, 'readwrite');
        var objectStore = transaction.objectStore(type);

        return _Promise.all(records.map(function (record) {
          return new _Promise(function (resolve, reject) {
            var request = objectStore.add(record);
            request.onsuccess = resolve;
            request.onerror = function (event) {
              if (event.target.error.name === 'ConstraintError') return reject(new ConflictError('Unique key constraint violated.'));

              return reject(event.target.error);
            };
          });
        })).then(function () {
          return records.map(_helpers.outputRecord.bind(_this2, type));
        });
      }
    }, {
      key: 'find',
      value: function find(type, ids, options) {
        var _this3 = this;

        if (ids && !ids.length) return _get(Object.getPrototypeOf(IndexedDBAdapter.prototype), 'find', this).call(this);

        var db = this.db;
        var recordTypes = this.recordTypes;

        var fields = recordTypes[type];
        var transaction = db.transaction(type, 'readonly');
        var objectStore = transaction.objectStore(type);
        var records = [];
        var count = 0;

        return (ids ? new _Promise(function (resolve, reject) {
          var counter = 0;
          var verifyGet = function verifyGet(event) {
            var record = event.target.result;
            if (record) {
              records.push(record);
              count++;
            }
            counter++;
            if (counter === ids.length) return resolve(records);
          };

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _getIterator(ids), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var id = _step.value;

              var request = objectStore.get(type + _helpers.delimiter + id);
              request.onsuccess = verifyGet;
              request.onerror = reject;
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator['return']) {
                _iterator['return']();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }) : new _Promise(function (resolve, reject) {
          var cursor = objectStore.openCursor();
          cursor.onsuccess = function (event) {
            var iterator = event.target.result;
            if (iterator) {
              count++;
              records.push(iterator.value);
              return iterator['continue']();
            }
            return resolve(records);
          };
          cursor.onerror = reject;
        })).then(function (records) {
          // Unfortunately, IndexedDB doesn't have native support for most of what
          // we want to query for, so we have to implement it ourselves.
          records = (0, _common.applyOptions)(count, fields, records, options);
          count = records.count;

          var result = records.map(_helpers.outputRecord.bind(_this3, type));
          result.count = count;

          return result;
        });
      }
    }, {
      key: 'update',
      value: function update(type, updates) {
        if (!updates.length) return _get(Object.getPrototypeOf(IndexedDBAdapter.prototype), 'update', this).call(this);

        var db = this.db;
        var primaryKey = this.keys.primary;

        var transaction = db.transaction(type, 'readwrite');
        var objectStore = transaction.objectStore(type);
        var found = 0;
        var count = 0;
        var done = 0;

        return new _Promise(function (resolve, reject) {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = _getIterator(updates), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var update = _step2.value;

              var getRequest = objectStore.get(type + _helpers.delimiter + update[primaryKey]);
              getRequest.onerror = reject;
              getRequest.onsuccess = doUpdate.bind(null, update);
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                _iterator2['return']();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          function doUpdate(update, event) {
            found++;

            var record = event.target.result;

            // If we found all records and there's nothing to update,
            // resolve with 0.
            if (!record) return found === updates.length && !count ? resolve(0) : null;

            count++;

            (0, _commonApply_update2['default'])(record, update);

            var putRequest = objectStore.put(record);
            putRequest.onerror = reject;
            putRequest.onsuccess = function () {
              done++;
              if (done === found) return resolve(count);
            };
          }
        });
      }
    }, {
      key: 'delete',
      value: function _delete(type, ids) {
        if (ids && !ids.length) return _get(Object.getPrototypeOf(IndexedDBAdapter.prototype), 'delete', this).call(this);

        var db = this.db;

        var transaction = db.transaction(type, 'readwrite');
        var objectStore = transaction.objectStore(type);

        if (ids) return new _Promise(function (resolve, reject) {
          var idSet = new _Set();
          var count = 0;

          // In order to ensure correct execution order, use 2 loops.

          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = _getIterator(ids), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var id = _step3.value;

              var getRequest = objectStore.get(type + _helpers.delimiter + id);
              getRequest.onsuccess = verifyGet.bind(null, id);
              getRequest.onerror = reject;
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                _iterator3['return']();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }

          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = _getIterator(ids), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var id = _step4.value;

              var deleteRequest = objectStore['delete'](type + _helpers.delimiter + id);
              deleteRequest.onsuccess = verifyDelete.bind(null, id);
              deleteRequest.onerror = reject;
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                _iterator4['return']();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }

          function verifyDelete(id) {
            if (idSet.has(id)) count++;
            if (count === idSet.size) return resolve(count);
          }

          function verifyGet(id, event) {
            if (event.target.result) idSet.add(id);
          }
        });

        return new _Promise(function (resolve, reject) {
          var count = undefined;

          var countRequest = objectStore.count();
          countRequest.onsuccess = function (event) {
            return count = event.target.result;
          };
          countRequest.onerror = reject;

          var clearRequest = objectStore.clear();
          clearRequest.onsuccess = function () {
            return resolve(count);
          };
          clearRequest.onerror = reject;
        });
      }
    }]);

    return IndexedDBAdapter;
  })(Adapter);
};

module.exports = exports['default'];