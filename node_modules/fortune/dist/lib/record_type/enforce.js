'use strict';

var _WeakMap = require('babel-runtime/core-js/weak-map')['default'];

var _Number$isNaN = require('babel-runtime/core-js/number/is-nan')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = enforce;

var _commonErrors = require('../common/errors');

var _commonKeys = require('../common/keys');

// Check input values.
var checkInput = new _WeakMap([[String, function (value) {
  return typeof value === 'string';
}], [Number, function (value) {
  return typeof value === 'number';
}], [Boolean, function (value) {
  return typeof value === 'boolean';
}], [Date, function (value) {
  return value instanceof Date && !_Number$isNaN(value.valueOf());
}], [Object, function (value) {
  return value !== null && typeof value === 'object';
}], [Buffer, function (value) {
  return Buffer.isBuffer(value);
}]]);

/**
 * Throw errors for mismatched types on a record.
 *
 * @param {String} type
 * @param {Object} record
 * @param {Object} fields
 * @return {Object}
 */

function enforce(type, record, fields) {
  for (var key in record) {
    if (!(key in fields)) {
      if (key !== _commonKeys.primary) delete record[key];
      continue;
    }

    var value = record[key];

    if (_commonKeys.type in fields[key]) {
      if (fields[key][_commonKeys.isArray]) {
        // If the field is defined as an array but the value is not,
        // then throw an error.
        if (!Array.isArray(value)) throw new _commonErrors.BadRequestError('The value of "' + key + '" is ' + 'invalid, it must be an array with values of type ' + (fields[key][_commonKeys.type].name.toLowerCase() + '.'));

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = _getIterator(value), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var item = _step.value;

            checkValue(fields[key], key, item);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else checkValue(fields[key], key, value);

      continue;
    }

    if (_commonKeys.link in fields[key]) {
      if (fields[key][_commonKeys.isArray]) {
        if (!Array.isArray(value)) throw new _commonErrors.BadRequestError('The value of "' + key + '" is ' + 'invalid, it must be an array.');

        if (type === fields[key][_commonKeys.link] && value.some(findPrimary.bind(null, record))) throw new _commonErrors.BadRequestError('An ID of "' + key + '" is ' + 'invalid, it cannot be the ID of the record.');

        continue;
      }

      if (Array.isArray(value)) throw new _commonErrors.BadRequestError('The value of "' + key + '" is ' + 'invalid, it must be a singular value.');

      if (type === fields[key][_commonKeys.link] && findPrimary(record, value)) throw new _commonErrors.BadRequestError('The ID of "' + key + '" is ' + 'invalid, it cannot be the ID of the record.');

      continue;
    }
  }

  return record;
}

function checkValue(field, key, value) {
  // If the field type is a symbol, then there is nothing to enforce.
  if (typeof field[_commonKeys.type] === 'symbol') return;

  // Fields may be nullable, but if they're defined, then they must be defined
  // properly.
  if (value !== null && !checkInput.get(field[_commonKeys.type])(value)) throw new _commonErrors.BadRequestError(field[_commonKeys.isArray] ? 'A value in the array of "' + key + '" is invalid, it must be a ' + (field[_commonKeys.type].name.toLowerCase() + '.') : 'The value of "' + key + '" is invalid, it must be a ' + (field[_commonKeys.type].name.toLowerCase() + '.'));
}

function findPrimary(record, id) {
  return record[_commonKeys.primary] === id;
}
module.exports = exports['default'];