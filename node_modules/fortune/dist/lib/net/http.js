'use strict';

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _WeakMap = require('babel-runtime/core-js/weak-map')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = http;

var _zlib = require('zlib');

var _zlib2 = _interopRequireDefault(_zlib);

var _negotiator = require('negotiator');

var _negotiator2 = _interopRequireDefault(_negotiator);

var _ = require('../');

var _2 = _interopRequireDefault(_);

var _commonErrors = require('../common/errors');

var _commonSuccess = require('../common/success');

var beforeSemicolon = /[^;]*/;
var availableEncodings = ['gzip', 'deflate'];

/**
 * This function maps HTTP on to Fortune, it's a static method available at
 * `Fortune.net.http`. The integration with Fortune is minimal, passing in
 * which serializers to use, assigning request headers to the `meta` object,
 * and reading the request body, and mapping the response from the `request`
 * method on to the HTTP response. If the payload is an object, it will be cast
 * into a JSON string. The listener function ends the response and returns a
 * promise that is resolved when the response is ended. The returned promise
 * may be rejected with the error response, providing a hook for error logging.
 *
 * The options object may be formatted as follows:
 *
 * ```js
 * {
 *   // By default, the listener will end the response, set this to `false` if
 *   // the response will be ended later.
 *   endResponse: true,
 *
 *   // Use compression if the request `Accept-Encoding` header allows it. Note
 *   // that Buffer-typed responses will not be compressed. This option should
 *   // be disabled in case of a reverse proxy which handles compression.
 *   compression: true,
 *
 *   // JSON specific settings.
 *   json: {
 *     // How many spaces to indent. For example, use `2` for pretty printing.
 *     spaces: 0,
 *
 *     // Character encoding for buffers.
 *     bufferEncoding: 'base64'
 *   }
 * }
 * ```
 *
 * @param {Fortune} instance
 * @param {Object} [options]
 * @return {Function}
 */

function http(instance) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  if (!(instance instanceof _2['default'])) throw new Error('An instance of Fortune is required.');

  var endResponse = 'endResponse' in options ? options.endResponse : true;
  var compression = 'compression' in options ? options.compression : true;

  // We can take advantage of the closure provided by the `http` wrapper
  // function which has a reference to the Fortune instance.
  return function (request, response) {
    var negotiator = new _negotiator2['default'](request);

    var options = {
      // Using Negotiator to get the highest priority media type.
      serializerOutput: negotiator.mediaType(instance.serializer.ids),

      // Get the media type of the request.
      // See RFC 2045: https://www.ietf.org/rfc/rfc2045.txt
      serializerInput: beforeSemicolon.exec(request.headers['content-type'] || '')[0] || null,

      meta: request.headers
    };

    if (options.serializerOutput) response.setHeader('Content-Type', options.serializerOutput);

    if (compression) {
      var encoding = negotiator.encoding(availableEncodings);
      if (encoding) response.setHeader('Content-Encoding', encoding);
    }

    // Set status code to null value, which we can check later if status code
    // should be overwritten or not.
    response.statusCode = null;

    return new _Promise(function (resolve, reject) {
      var chunks = [];

      request.on('error', function (error) {
        response.setHeader('Content-Type', 'text/plain');
        error.payload = 'The request body is invalid.';
        reject(error);
      });

      request.on('data', function (chunk) {
        return chunks.push(chunk);
      });
      request.on('end', function () {
        return resolve(Buffer.concat(chunks));
      });
    }).then(function (body) {
      if (body.length) options.payload = body;

      // Pass the options and system request/response objects to Fortune.
      return instance.request(options, request, response);
    }).then(end.bind(null, request, response), function (contextResponse) {
      return end(request, response, contextResponse).then(function () {
        throw contextResponse;
      });
    });
  };

  // Internal function to end the response.
  function end(request, response, contextResponse) {
    var payload = contextResponse.payload;
    var meta = contextResponse.meta;

    if (response.statusCode === null) response.statusCode = http.statusMap.get(contextResponse.constructor) || http.statusMap.get(Error);

    // The special `Connection` header notifies Node.js that the server should
    // be persisted, unless explicitly specified otherwise.
    // See: https://serverfault.com/questions/322683
    var connection = request.headers['connection'];
    if (!(connection && connection.toLowerCase() === 'close')) response.setHeader('Connection', 'keep-alive');

    return new _Promise(function (resolve) {
      if (Buffer.isBuffer(payload)) meta['Content-Length'] = payload.length;else if (payload && typeof payload === 'object') payload = contextResponse.payload = http.stringify(payload, options.json || {});

      if (typeof payload === 'string') {
        var encoding = response.getHeader('content-encoding');

        if (encoding && ~availableEncodings.indexOf(encoding)) return _zlib2['default'][encoding](payload, function (error, result) {
          if (error) throw error;
          payload = contextResponse.payload = result;
          meta['Content-Length'] = payload.length;
          return resolve();
        });

        payload = contextResponse.payload = new Buffer(payload);
        meta['Content-Length'] = payload.length;
        return resolve();
      }

      response.removeHeader('Content-Encoding');
      response.removeHeader('Content-Type');
      return resolve();
    }).then(function () {
      return new _Promise(function (resolve) {
        for (var field in meta) {
          response.setHeader(field, meta[field]);
        }return endResponse ? response.end(payload, function () {
          return resolve(contextResponse);
        }) : resolve(contextResponse);
      });
    })['catch'](function (error) {
      return new _Promise(function (resolve) {
        var message = error.toString();
        response.statusCode = http.statusMap.get(Error);
        response.setHeader('Content-Type', 'text/plain');
        response.setHeader('Content-Length', Buffer.byteLength(message));
        response.end(message, function () {
          return resolve(error);
        });
      });
    });
  }
}

// Map successes and errors to HTTP status codes.
http.statusMap = new _WeakMap([[_commonSuccess.OK, 200], [_commonSuccess.Created, 201], [_commonSuccess.Empty, 204], [_commonErrors.BadRequestError, 400], [_commonErrors.UnauthorizedError, 401], [_commonErrors.ForbiddenError, 403], [_commonErrors.NotFoundError, 404], [_commonErrors.MethodError, 405], [_commonErrors.NotAcceptableError, 406], [_commonErrors.ConflictError, 409], [_commonErrors.UnsupportedError, 415], [Error, 500]]);

// Stringify objects using a replacer function.
http.stringify = function (object, options) {
  var bufferEncoding = 'bufferEncoding' in options ? options.bufferEncoding : 'base64';
  var spaces = 'spaces' in options ? options.spaces : 0;

  return JSON.stringify(object, function (key, value) {
    // Duck type checking for buffer stringification.
    if (value && value.type === 'Buffer' && Array.isArray(value.data) && _Object$keys(value).length === 2) return new Buffer(value.data).toString(bufferEncoding);

    return value;
  }, spaces);
};
module.exports = exports['default'];