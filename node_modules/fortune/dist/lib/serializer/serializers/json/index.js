'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _Object$defineProperties = require('babel-runtime/core-js/object/define-properties')['default'];

var _Number$parseFloat = require('babel-runtime/core-js/number/parse-float')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _default = require('../../default');

var _default2 = _interopRequireDefault(_default);

var inBrackets = /\[([^\]]+)\]/;
var isMatch = /^match/;

exports['default'] = function () {
  return _Object$assign(

  /**
   * This is an ad hoc JSON-over-HTTP serializer, it is missing some features
   * since it tries to limit itself to JSON-serializable objects and does not try
   * to include any special keys in the payload. Notably, the `include` option is
   * missing.
   */
  (function (_DefaultSerializer) {
    _inherits(JsonSerializer, _DefaultSerializer);

    function JsonSerializer() {
      _classCallCheck(this, JsonSerializer);

      _get(Object.getPrototypeOf(JsonSerializer.prototype), 'constructor', this).apply(this, arguments);

      var _methods = this.methods;
      var findMethod = _methods.find;
      var createMethod = _methods.create;
      var updateMethod = _methods.update;
      var deleteMethod = _methods['delete'];

      var methodMap = {
        'GET': findMethod,
        'POST': createMethod,
        'PATCH': updateMethod,
        'DELETE': deleteMethod
      };

      _Object$defineProperties(this, {
        methodMap: { value: methodMap }
      });
    }

    _createClass(JsonSerializer, [{
      key: 'processRequest',
      value: function processRequest(context) {
        // If the request was initiated without HTTP arguments, this is a no-op.
        if (arguments.length === 1) return context;

        var recordTypes = this.recordTypes;
        var methodMap = this.methodMap;
        var castValue = this.castValue;
        var NotFoundError = this.errors.NotFoundError;
        var typeKey = this.keys.type;

        var request = arguments[1];

        var _url$parse = _url2['default'].parse(request.url, true);

        var pathname = _url$parse.pathname;
        var query = _url$parse.query;

        var parts = pathname.slice(1).split('/');

        if (parts.length > 2) throw new NotFoundError('Invalid path.');

        context.request.method = methodMap[request.headers['x-http-method-override'] || request.headers['x-method-override'] || request.headers['x-http-method'] || request.method];
        context.request.type = decodeURIComponent(parts[0]) || null;
        context.request.ids = parts[1] ? decodeURIComponent(parts[1]).split(',').map(function (id) {
          // Stolen from jQuery source code:
          // https://api.jquery.com/jQuery.isNumeric/
          var float = _Number$parseFloat(id);
          return id - float + 1 >= 0 ? float : id;
        }) : null;

        var fields = recordTypes[context.request.type];
        var options = context.request.options;

        options.limit = 'limit' in query ? parseInt(query.limit, 10) : 1000;
        options.offset = 'offset' in query ? parseInt(query.offset, 10) : 0;

        if ('fields' in query) options.fields = query.fields.split(',').reduce(function (fields, field) {
          fields[field] = true;
          return fields;
        }, {});

        // Attach match option.
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = _getIterator(_Object$keys(query)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var parameter = _step.value;

            if (parameter.match(isMatch)) {
              if (!options.match) options.match = {};
              var field = (parameter.match(inBrackets) || [])[1];
              var fieldType = fields[field][typeKey];
              var value = query[parameter];

              options.match[field] = Array.isArray(value) ? value.map(castMap.bind(null, fieldType, options)) : castValue(value, fieldType, options);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        if ('sort' in query) options.sort = query.sort.split(',').reduce(function (sort, field) {
          var firstChar = field.charAt(0);

          if (firstChar === '-') sort[field.slice(1)] = false;else sort[field] = true;

          return sort;
        }, {});

        return context;
      }
    }, {
      key: 'processResponse',
      value: function processResponse(context, request, response) {
        if (arguments.length === 1) return context;

        // Set the charset to UTF-8.
        response.setHeader('Content-Type', JsonSerializer.id + '; charset=utf-8');

        return context;
      }
    }, {
      key: 'showResponse',
      value: function showResponse(context) {
        var _methods2 = this.methods;
        var updateMethod = _methods2.update;
        var deleteMethod = _methods2['delete'];
        var method = context.request.method;
        var updateModified = context.response.updateModified;

        // Delete and update requests may not respond with anything.
        if (method === deleteMethod || method === updateMethod && !updateModified) return context;

        return _get(Object.getPrototypeOf(JsonSerializer.prototype), 'showResponse', this).apply(this, arguments);
      }
    }, {
      key: 'parseCreate',
      value: function parseCreate(context) {
        context.request.payload = parseBuffer.call(this, context.request.payload);

        var records = _get(Object.getPrototypeOf(JsonSerializer.prototype), 'parseCreate', this).call(this, context);
        var options = this.options;
        var recordTypes = this.recordTypes;
        var castValue = this.castValue;
        var typeKey = this.keys.type;
        var type = context.request.type;

        var fields = recordTypes[type];
        var cast = function cast(type, options) {
          return function (value) {
            return castValue(value, type, options);
          };
        };

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = _getIterator(records), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var record = _step2.value;

            for (var field in record) {
              var value = record[field];
              var fieldDefinition = fields[field] || {};
              var fieldType = fieldDefinition[typeKey];

              record[field] = Array.isArray(value) ? value.map(cast(fieldType, options)) : castValue(value, fieldType, options);
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
              _iterator2['return']();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        return records;
      }
    }, {
      key: 'parseUpdate',
      value: function parseUpdate(context) {
        context.request.payload = parseBuffer.call(this, context.request.payload);

        var updates = _get(Object.getPrototypeOf(JsonSerializer.prototype), 'parseUpdate', this).call(this, context);
        var options = this.options;
        var recordTypes = this.recordTypes;
        var castValue = this.castValue;
        var typeKey = this.keys.type;
        var type = context.request.type;

        var fields = recordTypes[type];
        var cast = function cast(type, options) {
          return function (value) {
            return castValue(value, type, options);
          };
        };

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = _getIterator(updates), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var update = _step3.value;

            castFields(update.replace, update.push, update.pull);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3['return']) {
              _iterator3['return']();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        return updates;

        function castFields() {
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = _getIterator(arguments), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var object = _step4.value;

              for (var field in object) {
                var value = object[field];
                var fieldDefinition = fields[field] || {};
                var fieldType = fieldDefinition[typeKey];

                object[field] = Array.isArray(value) ? value.map(cast(fieldType, options)) : castValue(value, fieldType, options);
              }
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                _iterator4['return']();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        }
      }
    }]);

    return JsonSerializer;
  })(_default2['default']), { id: 'application/json' });
};

function parseBuffer(payload) {
  var BadRequestError = this.errors.BadRequestError;

  if (!Buffer.isBuffer(payload)) return null;

  try {
    return JSON.parse(payload.toString());
  } catch (error) {
    throw new BadRequestError('Invalid JSON: ' + error.message);
  }
}
module.exports = exports['default'];