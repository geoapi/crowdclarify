'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$defineProperties = require('babel-runtime/core-js/object/define-properties')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _Object$getOwnPropertyNames = require('babel-runtime/core-js/object/get-own-property-names')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _interopRequireWildcard = require('babel-runtime/helpers/interop-require-wildcard')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _ = require('./');

var _2 = _interopRequireDefault(_);

var _default = require('./default');

var _default2 = _interopRequireDefault(_default);

var _cast_value = require('./cast_value');

var _cast_value2 = _interopRequireDefault(_cast_value);

var _commonKeys = require('../common/keys');

var keys = _interopRequireWildcard(_commonKeys);

var _commonErrors = require('../common/errors');

var errors = _interopRequireWildcard(_commonErrors);

var _commonMethods = require('../common/methods');

var methods = _interopRequireWildcard(_commonMethods);

var UnsupportedError = errors.UnsupportedError;
var NotAcceptableError = errors.NotAcceptableError;
var BadRequestError = errors.BadRequestError;
var nativeErrors = errors.nativeErrors;

/**
 * Reroute the publicly accessed methods of the serializer to an underlying
 * serializer matching the context. For internal use.
 */

var SerializerSingleton = (function (_Serializer) {
  _inherits(SerializerSingleton, _Serializer);

  function SerializerSingleton(dependencies) {
    _classCallCheck(this, SerializerSingleton);

    _get(Object.getPrototypeOf(SerializerSingleton.prototype), 'constructor', this).call(this);

    var recordTypes = dependencies.recordTypes;
    var adapter = dependencies.adapter;
    var serializers = dependencies.serializers;

    var ids = [];
    var types = serializers ? serializers.reduce(function (types, serializer) {
      var type = serializer.type;

      if (typeof type !== 'function') throw new TypeError('The serializer must be a function or class.');

      var CustomSerializer = _2['default'].prototype.isPrototypeOf(type.prototype) ? type : type(_2['default']);

      if (!_2['default'].prototype.isPrototypeOf(CustomSerializer.prototype)) throw new TypeError('The serializer must be a class that extends ' + 'Serializer.');

      var id = CustomSerializer.id;

      if (!id) throw new Error('The serializer must have a static property ' + 'named "id".');

      ids.push(id);

      types[id] = new CustomSerializer({
        options: serializer.options || {},
        methods: methods, keys: keys, errors: errors, recordTypes: recordTypes, adapter: adapter, castValue: _cast_value2['default']
      });

      return types;
    }, {}) : {};

    _Object$defineProperties(this, {

      // Internal property to keep instances of serializers.
      types: { value: types },

      // Internal instance of the default serializer.
      defaultSerializer: {
        value: new _default2['default']({ recordTypes: recordTypes, errors: errors })
      },

      // Array of IDs ordered by priority.
      ids: { value: ids }

    });

    assignSerializerProxy.call(this);
  }

  return SerializerSingleton;
})(_2['default']);

exports['default'] = SerializerSingleton;

var inputMethods = new _Set(['parseCreate', 'parseUpdate']);

// Assign the proxy methods on top of the base methods.
function assignSerializerProxy() {
  var _this = this;

  var prototype = Object.getPrototypeOf(this);
  var methods = _Object$getOwnPropertyNames(_2['default'].prototype).filter(function (name) {
    return name !== 'constructor';
  });

  _Object$assign(prototype, methods.reduce(function (proxy, method) {
    var isInput = inputMethods.has(method);

    proxy[method] = proxyMethod.bind(_this, {
      method: method, isInput: isInput,
      NoopError: isInput ? UnsupportedError : NotAcceptableError
    });

    return proxy;
  }, {}));
}

// Internal proxy method to call serializer method based on context.
function proxyMethod(options, context) {
  var types = this.types;
  var defaultSerializer = this.defaultSerializer;
  var NoopError = options.NoopError;
  var isInput = options.isInput;
  var method = options.method;

  var format = context.request[isInput ? 'serializerInput' : 'serializerOutput'];
  var serializer = undefined;

  // If a serializer is specified, use it.
  if (format in types) serializer = types[format];

  // Fall back to default serializer.
  else if (!format) serializer = defaultSerializer;

    // Fail if no serializer was found.
    else throw new NoopError('The serializer for "' + format + '" is unrecognized.');

  try {
    var _serializer;

    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    return _Promise.resolve((_serializer = serializer)[method].apply(_serializer, [context].concat(args)));
  } catch (e) {
    var error = e;

    // Only in the special case of input methods, it may be more appropriate to
    // throw a BadRequestError.
    if (nativeErrors.has(error.constructor) && isInput) error = new BadRequestError('The request is malformed.');

    return _Promise.reject(error);
  }
}
module.exports = exports['default'];