'use strict';

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _Object$freeze = require('babel-runtime/core-js/object/freeze')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _interopRequire = require('babel-runtime/helpers/interop-require')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = dispatch;

var _promiseCompose = require('promise-compose');

var _promiseCompose2 = _interopRequireDefault(_promiseCompose);

var _commonMethods = require('../common/methods');

var _commonSuccess = require('../common/success');

var _commonErrors = require('../common/errors');

var _create = require('./create');

exports.create = _interopRequire(_create);

var _delete = require('./delete');

exports['delete'] = _interopRequire(_delete);

var _update = require('./update');

exports.update = _interopRequire(_update);

var _find = require('./find');

exports.find = _interopRequire(_find);

var _include = require('./include');

exports.include = _interopRequire(_include);

var _end = require('./end');

exports.end = _interopRequire(_end);

// Set Promise shim if needed.
_promiseCompose2['default'].Promise = _Promise;

/*!
 * Internal function to dispatch a request.
 *
 * @param {Object} options
 * @param {...*} [args]
 * @return {Promise}
 */

function dispatch(options) {
  var _this = this;

  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var _serializer = this.serializer;
  var processRequest = _serializer.processRequest;
  var processResponse = _serializer.processResponse;
  var showError = _serializer.showError;
  var recordTypes = this.recordTypes;

  var context = setDefaults(options);

  // Start a promise chain.
  return _Promise.resolve(context)

  // Try to process the request.
  .then(function (context) {
    return processRequest.apply(undefined, [context].concat(args));
  }).then(function (context) {
    var _context$request = context.request;
    var method = _context$request.method;
    var type = _context$request.type;
    var ids = _context$request.ids;

    // Make sure that IDs are an array of unique, non-falsy values.
    if (ids) context.request.ids = [].concat(_toConsumableArray(new _Set((Array.isArray(ids) ? ids : [ids]).filter(function (id) {
      return id;
    }))));

    // If a type is unspecified, block the request.
    if (type === null && method !== _commonMethods.find && typeof method !== 'function') throw new _commonErrors.BadRequestError('The type is unspecified.');

    // If a type is specified and it doesn't exist, block the request.
    if (type !== null && !(type in recordTypes)) throw new _commonErrors.NotFoundError('The requested type "' + type + '" is not a valid type.');

    return typeof method === 'function' ? method(context) : runMethod.call(_this, method, context);
  }).then(function (context) {
    return processResponse.apply(undefined, [context].concat(args));
  }).then(function (context) {
    var method = context.request.method;
    var payload = context.response.payload;
    var response = context.response;

    if (method === _commonMethods.create) return new _commonSuccess.Created(response);
    if (!payload) return new _commonSuccess.Empty(response);

    return new _commonSuccess.OK(response);
  })['catch'](function (error) {
    return _Promise.resolve(showError(context, _commonErrors.nativeErrors.has(error.constructor) ? new Error('An internal server error occurred.') : error)).then(function (context) {
      return _Promise.resolve(processResponse.apply(undefined, [context].concat(args)));
    }).then(function (context) {
      throw _Object$assign(error, context.response);
    });
  });
}

/*!
 * Internal function to run a flow, must be bound to an instance.
 *
 * @param {String} method
 * @param {Object} context
 * @return {Promise}
 */
function runMethod(method, context) {
  var flows = this.flows;

  // Block invalid method.
  if (!(method in flows)) throw new _commonErrors.MethodError('The method "' + method + '" is unrecognized.');

  return _promiseCompose2['default'].apply(undefined, _toConsumableArray(flows[method]))(context);
}

/*!
 * Set default options on a context's request. For internal use.
 *
 * @param {Object} [options]
 * @return {Object}
 */
function setDefaults(options) {
  var context = _Object$freeze({
    request: {
      method: _commonMethods.find,
      type: null,
      ids: null,
      options: {},
      include: [],
      includeOptions: {},
      serializerInput: null,
      serializerOutput: null,
      meta: {},
      payload: null
    },
    response: {
      meta: {},
      payload: null
    }
  });

  _Object$assign(context.request, options);

  return context;
}