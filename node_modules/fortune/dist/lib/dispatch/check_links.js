'use strict';

var _defineProperty = require('babel-runtime/helpers/define-property')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = checkLinks;

var _commonKeys = require('../common/keys');

/**
 * Ensure referential integrity by checking if related records exist.
 *
 * @param {Object} record
 * @param {Object} fields
 * @param {String[]} links - An array of strings indicating which fields are
 * links. Need to pass this so that it doesn't get computed each time.
 * @param {Object} [meta]
 * @return {Promise}
 */

function checkLinks(record, fields, links, meta) {
  var adapter = this.adapter;
  var enforceLinks = this.options.enforceLinks;

  return _Promise.all(links.map(function (field) {
    return new _Promise(function (resolve, reject) {
      var ids = Array.isArray(record[field]) ? record[field] : !(field in record) || record[field] === null ? [] : [record[field]];
      var fieldLink = fields[field][_commonKeys.link];
      var fieldInverse = fields[field][_commonKeys.inverse];

      return !ids.length ? resolve() : adapter.find(fieldLink, ids, {
        // Don't need the entire records.
        fields: _defineProperty({}, fieldInverse, true)
      }, meta).then(function (records) {
        if (enforceLinks) {
          var recordIds = new _Set(records.map(function (record) {
            return record[_commonKeys.primary];
          }));

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _getIterator(ids), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var id = _step.value;
              if (!recordIds.has(id)) return reject(new Error('A related record for the field "' + field + '" was not found.'));
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator['return']) {
                _iterator['return']();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }

        return resolve(records);
      });
    });
  })).then(function (partialRecords) {
    var object = {};

    for (var index = 0; index < partialRecords.length; index++) {
      var records = partialRecords[index];

      if (records) object[links[index]] = fields[links[index]][_commonKeys.isArray] ? records : records[0];
    }

    return object;
  });
}

module.exports = exports['default'];