'use strict';

var _defineProperty = require('babel-runtime/helpers/define-property')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _commonKeys = require('../common/keys');

var _commonArray_proxy = require('../common/array_proxy');

/**
 * Fetch included records. This mutates `context`.response`
 * for the next method.
 *
 * @return {Promise}
 */

exports['default'] = function (context) {
  var _context$request = context.request;
  var type = _context$request.type;
  var ids = _context$request.ids;
  var include = _context$request.include;
  var meta = _context$request.meta;
  var records = context.response.records;

  if (!type || !include || !records) return context;

  var recordTypes = this.recordTypes;
  var adapter = this.adapter;

  // This cache is used to keep unique IDs per type.
  var idCache = _defineProperty({}, type, new _Set(ids));

  // It's necessary to iterate over primary records if no IDs were
  // provided initially.
  if (ids && !ids.length) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _getIterator(records), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var record = _step.value;

        idCache[type].add(record[_commonKeys.primary]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }return _Promise.all(include.map(function (fields) {
    return new _Promise(function (resolve, reject) {
      var currentType = type;
      var currentIds = [];
      var currentOptions = undefined;

      // Coerce field into an array.
      if (!Array.isArray(fields)) fields = [fields];

      // `cursor` refers to the current collection of records.
      return fields.reduce(function (records, field) {
        return records.then(function (cursor) {
          if (!currentType || !(field in recordTypes[currentType])) return [];

          var idCache = new _Set();

          currentType = recordTypes[currentType][field][_commonKeys.link];
          currentOptions = 'includeOptions' in context.request ? context.request.includeOptions[currentType] : null;
          currentIds = cursor.reduce(function (ids, record) {
            var linkedIds = Array.isArray(record[field]) ? record[field] : [record[field]];

            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = _getIterator(linkedIds), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var id = _step2.value;

                if (id && !idCache.has(id)) {
                  idCache.add(id);
                  ids.push(id);
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                  _iterator2['return']();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }

            return ids;
          }, []);

          var args = [currentType, currentIds];

          args.push(currentOptions ? currentOptions : null);
          if (meta) args.push(meta);

          return currentIds.length ? adapter.find.apply(adapter, args) : [];
        });
      }, _Promise.resolve(records)).then(function (records) {
        return resolve({
          type: currentType,
          ids: currentIds,
          records: records
        });
      }, function (error) {
        return reject(error);
      });
    });
  })).then(function (containers) {
    var include = containers.reduce(function (include, container) {
      if (!container.ids.length) return include;

      if (!(container.type in include)) include[container.type] = [];

      // Only include unique IDs per type.
      if (!(container.type in idCache)) idCache[container.type] = new _Set();

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = _getIterator(container.ids), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var id = _step3.value;

          if (idCache[container.type].has(id)) continue;

          var record = (0, _commonArray_proxy.find)(container.records, matchId.bind(null, id));

          if (record) {
            idCache[container.type].add(id);
            include[container.type].push(record);
          }
        }

        // If nothing so far, delete the type from include.
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3['return']) {
            _iterator3['return']();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      if (!include[container.type].length) delete include[container.type];

      return include;
    }, {});

    if (_Object$keys(include).length) Object.defineProperty(context.response, 'include', {
      configurable: true,
      value: include
    });

    return context;
  });
};

function matchId(id, record) {
  return record[_commonKeys.primary] === id;
}
module.exports = exports['default'];