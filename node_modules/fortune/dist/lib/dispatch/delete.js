'use strict';

var _defineProperty = require('babel-runtime/helpers/define-property')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _interopRequireWildcard = require('babel-runtime/helpers/interop-require-wildcard')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _clone = require('clone');

var _clone2 = _interopRequireDefault(_clone);

var _commonChange = require('../common/change');

var _commonChange2 = _interopRequireDefault(_commonChange);

var _commonMethods = require('../common/methods');

var _commonKeys = require('../common/keys');

var _commonErrors = require('../common/errors');

var _update_helpers = require('./update_helpers');

var updateHelpers = _interopRequireWildcard(_update_helpers);

/**
 * Delete records. This does not mutate context.
 *
 * @return {Promise}
 */

exports['default'] = function (context) {
  var _this = this;

  var _context$request = context.request;
  var type = _context$request.type;
  var ids = _context$request.ids;
  var meta = _context$request.meta;
  var adapter = this.adapter;
  var recordTypes = this.recordTypes;
  var transforms = this.transforms;

  var updates = {};
  var fields = recordTypes[type];
  var transform = transforms[type];
  var links = _Object$keys(fields).filter(function (field) {
    return _commonKeys.link in fields[field];
  });

  var transaction = undefined;
  var records = undefined;

  return (ids ? adapter.find(type, ids, null, meta) : _Promise.resolve([])).then(function (foundRecords) {
    records = foundRecords;

    if (ids) {
      if (!records.length) throw new _commonErrors.NotFoundError('There are no records to be deleted.');

      Object.defineProperty(context.response, 'records', {
        configurable: true,
        value: records
      });
    }

    return transform && transform.input ? _Promise.all(records.map(function (record) {
      return transform.input(context, (0, _clone2['default'])(record));
    })) : records;
  }).then(function () {
    return adapter.beginTransaction();
  }).then(function (t) {
    transaction = t;
    return transaction['delete'](type, ids, meta);
  }).then(function () {
    // Remove all instances of the deleted IDs in all records.
    var idCache = {};

    // Loop over each record to generate updates object.
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _getIterator(records), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var record = _step.value;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = _getIterator(links), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var field = _step2.value;

            var inverseField = fields[field][_commonKeys.inverse];

            if (!(field in record) || !inverseField) continue;

            var linkedType = fields[field][_commonKeys.link];
            var linkedIsArray = recordTypes[linkedType][inverseField][_commonKeys.isArray];
            var linkedIds = Array.isArray(record[field]) ? record[field] : [record[field]];

            // Do some initialization.
            if (!(linkedType in updates)) updates[linkedType] = [];
            if (!(linkedType in idCache)) idCache[linkedType] = new _Set();

            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = _getIterator(linkedIds), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var id = _step3.value;

                if (id !== null) updateHelpers.removeId(record[_commonKeys.primary], updateHelpers.getUpdate(linkedType, id, updates, idCache), inverseField, linkedIsArray);
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                  _iterator3['return']();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
              _iterator2['return']();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return _Promise.all(_Object$keys(updates).map(function (type) {
      return updates[type].length ? transaction.update(type, updates[type], meta) : null;
    }));
  }).then(function () {
    return transaction.endTransaction();
  })['catch'](function (error) {
    if (transaction) transaction.endTransaction(error);
    throw error;
  }).then(function () {
    var mapId = function mapId(update) {
      return update[_commonKeys.primary];
    };

    var eventData = _defineProperty({}, _commonMethods['delete'], _defineProperty({}, type, ids));

    if (_Object$keys(updates).length) {
      eventData[_commonMethods.update] = {};

      for (var _type in updates) {
        if (!updates[_type].length) continue;
        eventData[_commonMethods.update][_type] = updates[_type].map(mapId);
      }
    }

    // Summarize changes during the lifecycle of the request.
    _this.emit(_commonChange2['default'], eventData);

    return context;
  });
};

module.exports = exports['default'];